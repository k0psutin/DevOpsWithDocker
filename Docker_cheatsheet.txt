Useful docker commands:

#Download an image:

	docker pull <image>

#List all images:

	docker images 

#Remove all images:

	docker rmi -f $(docker images -q -a)

#Remove one or more images:

	docker rmi <image_id1 or name> <image_id2 or name>..

#List all running containers:

	docker ps

#List all containers:

	docker ps -a

#Stop a container:

	docker stop <container_id or name>

#Restart a container:

	docker restart <container_id or name>

#Remove all stopped containers:

	docker container prune

#Remove one and more containers

	docker rm <container_id or name> ...

#Run an image:

	docker run <flags <image> <optional_commands>

ie. docker run -it -p 3000:3000 ruby bash

#Search image from dockerhub:

	docker search <image>

optional flags can be used:

    --add-host list                  Add a custom host-to-IP mapping (host:ip)
  -a, --attach list                    Attach to STDIN, STDOUT or STDERR
      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)
      --blkio-weight-device list       Block IO weight (relative device weight) (default [])
      --cap-add list                   Add Linux capabilities
      --cap-drop list                  Drop Linux capabilities
      --cgroup-parent string           Optional parent cgroup for the container
      --cidfile string                 Write the container ID to the file
      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period
      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota
      --cpu-rt-period int              Limit CPU real-time period in microseconds
      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds
  -c, --cpu-shares int                 CPU shares (relative weight)
      --cpus decimal                   Number of CPUs
      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)
      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)
  -d, --detach                         Run container in background and print container ID
      --detach-keys string             Override the key sequence for detaching a container
      --device list                    Add a host device to the container
      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list
      --device-read-bps list           Limit read rate (bytes per second) from a device (default [])
      --device-read-iops list          Limit read rate (IO per second) from a device (default [])
      --device-write-bps list          Limit write rate (bytes per second) to a device (default [])
      --device-write-iops list         Limit write rate (IO per second) to a device (default [])
      --disable-content-trust          Skip image verification (default true)
      --dns list                       Set custom DNS servers
      --dns-option list                Set DNS options
      --dns-search list                Set custom DNS search domains
      --entrypoint string              Overwrite the default ENTRYPOINT of the image
  -e, --env list                       Set environment variables
      --env-file list                  Read in a file of environment variables
      --expose list                    Expose a port or a range of ports
      --group-add list                 Add additional groups to join
      --health-cmd string              Command to run to check health
      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)
      --health-retries int             Consecutive failures needed to report unhealthy
      --health-start-period duration   Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)
      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h) (default 0s)
      --help                           Print usage
  -h, --hostname string                Container host name
      --init                           Run an init inside the container that forwards signals and reaps processes
  -i, --interactive                    Keep STDIN open even if not attached
      --ip string                      IPv4 address (e.g., 172.30.100.104)
      --ip6 string                     IPv6 address (e.g., 2001:db8::33)
      --ipc string                     IPC mode to use
      --isolation string               Container isolation technology
      --kernel-memory bytes            Kernel memory limit
  -l, --label list                     Set meta data on a container
      --label-file list                Read in a line delimited file of labels
      --link list                      Add link to another container
      --link-local-ip list             Container IPv4/IPv6 link-local addresses
      --log-driver string              Logging driver for the container
      --log-opt list                   Log driver options
      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)
  -m, --memory bytes                   Memory limit
      --memory-reservation bytes       Memory soft limit
      --memory-swap bytes              Swap limit equal to memory plus swap: '-1' to enable unlimited swap
      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)
      --mount mount                    Attach a filesystem mount to the container
      --name string                    Assign a name to the container
      --network string                 Connect a container to a network (default "default")
      --network-alias list             Add network-scoped alias for the container
      --no-healthcheck                 Disable any container-specified HEALTHCHECK
      --oom-kill-disable               Disable OOM Killer
      --oom-score-adj int              Tune host's OOM preferences (-1000 to 1000)
      --pid string                     PID namespace to use
      --pids-limit int                 Tune container pids limit (set -1 for unlimited)
      --privileged                     Give extended privileges to this container
  -p, --publish list                   Publish a container's port(s) to the host
  -P, --publish-all                    Publish all exposed ports to random ports
      --read-only                      Mount the container's root filesystem as read only
      --restart string                 Restart policy to apply when a container exits (default "no")
      --rm                             Automatically remove the container when it exits
      --runtime string                 Runtime to use for this container
      --security-opt list              Security Options
      --shm-size bytes                 Size of /dev/shm
      --sig-proxy                      Proxy received signals to the process (default true)
      --stop-signal string             Signal to stop a container (default "SIGTERM")
      --stop-timeout int               Timeout (in seconds) to stop a container
      --storage-opt list               Storage driver options for the container
      --sysctl map                     Sysctl options (default map[])
      --tmpfs list                     Mount a tmpfs directory
  -t, --tty                            Allocate a pseudo-TTY
      --ulimit ulimit                  Ulimit options (default [])
  -u, --user string                    Username or UID (format: <name|uid>[:<group|gid>])
      --userns string                  User namespace to use
      --uts string                     UTS namespace to use
  -v, --volume list                    Bind mount a volume
      --volume-driver string           Optional volume driver for the container
      --volumes-from list              Mount volumes from the specified container(s)
  -w, --workdir string                 Working directory inside the container

Example: 

	-v volume from:to - ie: $(pwd):/usr/local/
	-p publish port host:container - ie: 80:8000
	-it interactive container . ie: list directories in shell

#Run a command in running container:

	docker exec <flags> <image_id> <command>

ie. docker exec -it image_test bash

Run a command in a running container

Options:

  -d, --detach               Detached mode: run command in the background
      --detach-keys string   Override the key sequence for detaching a container
  -e, --env list             Set environment variables
  -i, --interactive          Keep STDIN open even if not attached
      --privileged           Give extended privileges to the command
  -t, --tty                  Allocate a pseudo-TTY
  -u, --user string          Username or UID (format: <name|uid>[:<group|gid>])
  -w, --workdir string       Working directory inside the container

#attach to a running container

	docker attach <flags> <image_id>

Options:

   --detach-keys string   Override the key sequence for detaching a container
   --no-stdin             Do not attach STDIN
   --sig-proxy            Proxy all received signals to the process (default true)

--------------------------------------------------------------------------

#Dockerfiles, multistage and docker-compose.yml:



Example Dockerfile:


	FROM openjdk:8-jdk-alpine

	ENV <VARIABLE_TO_SET> <SETTING>

ie. ENV RAILS_ENV=production

	VOLUME /tmp

	COPY target/*.jar app.jar

        EXPOSE <port_number>

ie. EXPOSE 3000

	CMD ["java", "-jar", "app.jar"]


Dockerfiles are named 'Dockerfile' and can be build with 'docker build .'


You can also tag builds and use different filenames.

	docker build -t <name> -f <filename> <build dir>

ie. docker build -t openjdk -f Docker_openjdk /openjdk/.


	FROM <image base to build to>

If you want to create an image from scratch, use FROM scratch. 

	RUN <shell commands>

use RUN to install packages - ie. RUN apt-get install -y nodejs vim && npm install

	COPY <flags> <from> <where>

ie. COPY --from=build /src/local /src/local

To add a user:

	RUN adduser <flags> <user> && chown <flags> <user> <dir>

USER <user> to appoint a user for container.


--------------------------------------------------------------------------

ENTRYPOINT vs CMD can be confusing - in a properly set up image such as our youtube-dl the command represents an argument list for the entrypoint. By default entrypoint is set as /bin/sh and this is passed if no entrypoint is set. This is why giving path to a script file as CMD works: you’re giving the file as a parameter to /bin/sh.

In addition there are two ways to set them: exec form and shell form. We’ve been using the exec form where the command itself is executed. In shell form the command that is executed is wrapped with /bin/sh -c - it’s useful when you need to evaluate environment variables in the command like $MYSQL_PASSWORD or similar.

In the shell form the command is provided as a string without brackets. In the exec form the command and it’s arguments are provided as a list (with brackets), see the table below:

ENTRYPOINT /bin/ping -c 3 
CMD localhost

	/bin/sh -c ‘/bin/ping -c 3’ /bin/sh -c localhost

ENTRYPOINT [“/bin/ping”,”-c”,”3”] 
CMD localhost	

        /bin/ping -c 3 /bin/sh -c localhost

ENTRYPOINT /bin/ping -c 3 
CMD [“localhost”]	

        /bin/sh -c ‘/bin/ping -c 3’ localhost


ENTRYPOINT [“/bin/ping”,”-c”,”3”] 
CMD [“localhost”]	

        /bin/ping -c 3 localhost



#Multistage Dockerfile:

Use the first image to install libraries and build the application. The builder image is usually a larger one, and we can copy only the needed files to the production image.

   Multistage Dockerfile means that you build two images in a single Dockerfile.

	FROM <image> AS builder
	RUN <commands> 
        COPY <from> <where>
        RUN <maybe more installing>

- Then we add the production image.

	FROM <image> AS production
	COPY --from=builder <from> <where>
	RUN <maybe install something more>
	EXPOSE <port>
	CMD run server

#Docker-compose.yml:

With docker-compose, you can run multiple images/containers with a single file. You can also setup a volume and/or a network that all the containers can share. Note: only network can be shared in other docker-composes.

Example docker-compose.yml:

version: '3.5'

services:

        redis:
           image: redis
           container_name: redis
           volumes:
             - ./data:/data
           entrypoint: redis-server --appendonly yes
           ports:
             - 6379:6379
           restart: unless-stopped
         
        postgres:
           image: postgres
           restart: unless-stopped
           environment:
                  - POSTGRES_PASSWORD=mysecretpassword
           volumes:
             - ./db:/var/lib/postgresql/data
                   
        backend:
           build: backend-example-docker/.
           container_name: backend
           environment:
                  - FRONT_URL=http://localhost:5000
                  - REDIS=redis
                  - REDIS_PORT=6379
                  - DB_USERNAME=postgres
                  - DB_PASSWORD=mysecretpassword
                  - DB_NAME=postgres
                  - DB_HOST=postgres
           ports:
              - 8000:8000
           entrypoint: npm start
        

        frontend:
           build: frontend-example-docker/.
           container_name: frontend
           environment:
                  - API_URL=http://localhost:8000
           ports:
             - 5000:5000
           entrypoint: npm start

You can build and start the images with docker-compose.yml with:

	docker-compose up

To shutdown containers:	

	docker-compose down

Run multiple instances with scaling:

	docker-compose up --scale <amount>

#Networks:


You can also manually define the network and also its name in docker-compose version 3.5 forward. A major benefit of defining network is that it makes it easy to setup a configuration where other containers connect to an existing network as an external network.

Defining docker-compose.yml

	networks:
 	 database-network:
 	   name: server-database-network

To connect containers in another docker-compose.yml

	networks:
  	default:
  	  external:
   	   name: server-database-network


#Security and optimization:


Use multistage builds for images to keep image size low as possible.

Use docker-compose.yml to get rid of even more of the RUN layers from Dockerfiles.

Use USER to execute commands as a non-root user.



#Publishing projects in Docker Hub

	docker tag youtube-dl <username>/<repositoryname>

And the last thing we need is to authenticate our push by logging in:

	docker login

Pushing should now work without problems:

	docker push <username>/<repositoryname>

Pushing for heroku is almost the same, just use heroku cli for login etc..
